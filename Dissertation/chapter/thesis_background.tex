\chapter{Background}\label{chap:background}
\section{N-Queens}\label{sec:background_nqueens} 
Calculating the N-Queens problem has been a long tradition the computer science field and has been famously used in examples of backtracking\cite{golomb}, constraint satisfaction\cite{nadel1989constraint} and permutation generation\cite{swarm}.
		
Although the N-Queens problem is not a constraint satisfaction problem, it can be naturally formulated as one\cite{nadel1990representation}. Brute force techniques are mostly overlooked with the large number of possible arrangements and the low number of possible solutions. Although as there are set constraints on where the queen can be placed, we can use shortcuts in order to reduce the number of possible arrangements. For example limiting a single queen to a row, we reduce the total number of possible arrangements to \(8^8\). We could then blindly place a queen in each column/row and although this is still a very poor algorithm, it is one of the most efficient brute force algorithms. 
		
\input{./tables/solutions}
		
\input{./graphics/n4_backtracking}
Backtracking the N-Queens problem is a process of systematically placing queens and when we get to a position where no more queens can be placed, we backtrack to the previous placement and try the next available placement. In \ref{fig:n4_backtracking} we can see a full run through of the backtracking algorithm to a single solution. The algorithm will start by placing a queen in first available spot in the first row. It then moves onto the second row looking to place, there are two available locations, it will pick the furthest to the left first, although as it goes to place the third queen, it will find no available placements. It will then remove the last placed queen and place on the next available location. This continues until a solution is found although at this point the algorithm can return the board or increment the total number of solutions and then continue looking for solutions. This algorithm is complete and thus will find all possible solutions. This solution essentially creates a tree with the further you descend the tree, the more queens are placed on the board. 
		
An idea to compose a solution to the N-Queens problem by using the solutions to smaller n sizes was introduced by Ahrens\cite{ahrens}. Although the idea was limited by the fact it was only able to produce a strict class of solutions. Therefore it was a non complete solution unlike search based solutions.
		
Artificial Intelligence can also be used to solve the N-Queens problem\cite{sosic1990polynomial}. We can begin with a randomly generated board such as one where a single queen is placed in each row/column like in the brute force example. From this point we can count the number of attacks between each of the queens and attach values to the queen placements. We can use heuristics that uses this information to improve the placement of the queens and then analysing the placements again. The algorithms speed and efficiency is heavily based of the initial configuration of queens. This is a greedy algorithm meaning it will select the best option available at the moment. This isn't ideal for generating all solutions to the N-Queens problem as greedy algorithms are not complete.
		
The N-Queens algorithm is an NP-complete as well as \#P-complete algorithm. For a problem to be NP-complete it has to be in the set NP meaning it can be brute forced in polynomial time and can be reductable to a simulate every other NP problem. For the problem to be \#P it must belong in a class of problems that can be solved in polynomial time by a deterministic Turing machine.
		
\input{./graphics/symmetry}
		
When looking to find all solutions for a certain size \(n\), we can use the symmetry of the chess board to our advantage. As you can see in figure \ref{fig:symmetry}, we were able to derive a second solution to a four queen problem by reflecting the known solution. Although we have the two solutions to the 4 queen problem, only one solution is distinct and the other is a reflection/rotation. We call the distinct solution a fundamental solution. Each fundamental solution can have up to eight variant solutions (including it's original) by rotating 90, 180 and 270$^{\circ}$ and then reflecting each rotation on a fixed axis. This allows us to provide two values for the total number of solutions, the fundamental number of solutions and the total number of solutions. As you can see in table \ref{tab:solutions} the number of solutions increases dramatically with each increase of \(n\). \(n=27\) is the highest order board that has been completely enumerated. 

\section{Related Work}\label{sec:background_relatedwork} 

Given the N-Queens extensive history, it has gathered significant amount of study either looking to increase the known solutions or find real world applications. In 1986 the New Mexico State University Department of Computer Science released a paper detailing an N-Queens algorithm that could run concurrently\cite{Silver}. It used the programming language Modcap which is a block-structured function-based expression language. Although they did not have access to a parallel computer, after simulating how would run on a serial machine they came to the conclusion that it could run 300 times faster on a parallel system over serial execution. 

The next documented evidence of parallelization of the N-queens problem was in 2004 by The University of Electro-Communications in Tokyo\cite{kenji}. This team successfully calculated the total number of solutions to the 24-Queens problem on a 34-node PC cluster. A total of 227,514,171,973,736 solutions were calculated and took the cluster 22 days to calculate. The backtracking algorithm they used was heavily based off Jeff Somer's C program which I will go into detail about later in this paper. They designed a sequential program that is parallelized using MPI (Message Passing Interface). MPI allows for the distributed memory communication of nodes in a parallel system. I will be going into more detail about MPI later in this paper. 

Later in 2004 another project surfaced that aimed to solve the 25-queens problem\cite{caromel}. The research group was a group of individuals from the University of Nice Sophia Antipolis. This was achieved by using the spare CPU cycles of 260 machines using the ObjectWeb ProActive library. The total computation time was over 4,444hrs or 185 days. Although the accumulated computation time was 464,344hrs or over 53 years. The total number of solutions calculated is 2,207,893,435,808,352 and they were the first to do so. This really shows the power of parallel computing as they were able to execute the necessary tasks over 100 times quicker than on a serial system. 

The \(n = 26\) and \(n = 27\) were both first solved by TU Dresden (Technical University of Dresdon, Germany) in 2009 and 2016 respectively\cite{thomas}. To achieve this they used an FGPA (Field-Programmable Gate Array) implementation. FPGA's allows for a programmable hardware circuit that can be used to optimise a chip for a particular workload. The solution for \(n = 26\) was a massive 22,317,699,616,364,044 total solutions. It took another 7 years of research from various institutions to solve \(n = 27\) of the n-queens problem. It was again solved using FGPA's but these were greatly optimised and they exploited the use of symmetries to reduce the amount of computation drastically. This solution is where the record stands today with \(n = 28\) which will most likely have over (\(10^{18}\)) solutions.

The N-Queens algorithm is often studied as a "mathematical recreation" although there has been several real world applications directly linked to N-Queens solutions. Erbas, Tanik and Nair introduced a memory storage concept for parallel memory system making use of the N-Queen solutions allowing conflict free access to rows, columns and diagonals\cite{erbas1993circulant}. Tanik also went onto describe a method for deadlock prevention through the use of N-Queens. solutions\cite{tanik1978graph}. It has also been noted the N-Queens solutions could be used for VLSI (Very Large Scale Integration) testing and traffic control\cite{sosic1990polynomial}as well as image processing\cite{wang2006fast}. 

\section{Parallelisation}\label{sec:background_parallelisation } 
Parallel computing refers to the process of breaking down large computational problems into smaller parts that can be executed simultaneously across multiple processing cores that may communicate    via a shared memory. We can call these smaller parts concurrent processes. Concurrent computing is the set of serial (or sequential) programs that have the ability to run in parallel\cite{ben2006principles}. The aim of parallel computing is to increase the available computational power for problem solving. The problem is first split up into discrete parts that may be solved concurrently. Each of these parts are then broken down into a series of instructions that may run serially. Each of these parts are run on separate processing units simultaneously. A control mechanism can be put in place to control what processing units execute what parts. Although parallel computing now seems like the solution to all, in many situations serial computing is quicker and more efficient than parallel computation. Parallel slowdown is a phenomenon in which more time is spent communicating with other computers than processing data causing a communication bottleneck, slowing down the system. As long as a computational problem can be split into multiple discrete parts that may run serially and can be solved without parallel slowdown, parallel computing will always be the better option.

Communication between the parallel processes is not always necessary. As stated earlier, the N-Queens problem is perfectly parallel meaning it is trivial to split into the parallel tasks. For this the only communication needed will be to add up the total number of solutions at the end of execution.

In 1992 at the Supercomputing Conference the Message Passing Interface (MPI) forum was created with the intention of creating a standardisation for message passing between parallel processes\cite{gropp1996high}. With the assistance of more than 80 people from 40 organisations, version 1 of the MPI standard was released in 1994\cite{snir1998mpi}. MPI became a communication protocol for programming in parallel with each parallel process executing in isolation. Each process will have it's own dedicated memory space that the other processes do not have access to. Both process to process and collective communication is supported in the protocol. It has become the standard convention for communication among processes in distributed memory systems. 

The OpenMP API used in Fortran, C and C++ supports shared memory parallel programming. It can be used to develop parallel applications that make use of the same memory space. It can be seen as multiple processes running together sharing each others memory and resources\cite{chandra2001parallel}. Shared memory has it's benefits over distributed memory systems with shared memory being a lot easier to parallelize compared to distributed memory.    

I will be using MPI instead of OpenMP in my project for the reason that limited parallel communication is needed. If I used OpenMP, I would have to be careful with my memory management and process timing otherwise I could run into deadlock, race conditions and resource starvation\cite{ben2006principles}. I will be using the MPICH implementation of the MPI standardization\cite{gropp1996user}. This allows me to create MPI executables in Fortran77, Fortran90, C and C++. I can then execute the program and specify the number of processors the program will use. 

With that choice, I needed to decide on what language I would program this algorithm in. After doing some research I found that Fortran was much slower in parallel environments compared to C and C++ and gave a better speedup with the increase of cores\cite{young2016openmp}\cite{cary1997comparison}. C++ is a super set of C meaning it is based upon C and C++ has additional functionality over C. This includes modern OOP (Object Oriented Programming) concepts such as encapsulation and inheritance. When Bjarne Stroustrup created C++, it was evolved from C and nicknamed "C with classes"\cite{stroustrup1996history}. As I am familiar with OOP languages and am looking the set of OOP languages I understand, I will be developing this program in C++ over C and Fortran.  

This algorithm will require storage of the current board state, or more specifically the queen locations. The first obvious choice would be a two dimensional matrix of Boolean's. We could represent 0 as and empty board location and 1 as a queen placement.  
\input{./graphics/n8solutions}

